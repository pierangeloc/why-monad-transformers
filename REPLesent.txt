| \gFunctions, Effects, Composition

| Pierangelo Cecchetto
| @pierangelocecc


| \y\*\!VEON
---
| \* Functions composition
--


```
type A = String
type B = Int
type C = Boolean
```

--


```
val f: A => B = s => s.length
val g: B => C = n => n % 2 == 0
```

--

Types Aligned :thumbsup::thumbsup:

--

Compose

```
val evenLength: A => C = s => g(f(s))
```
--

```
val evenLength = g compose f
val evenLength2 = f andThen g
```

--
N.B.: Function Composition is associative
(f compose g) compose h === f compose (g compose h)

---
| \* Effectful Computations
--

--
```
def mean(xs: List[Int]): Int = xs.sum / xs.length
```
--

```
mean(List(4, 6, 5))
```
--

:see_no_evil:

```
mean(List())
```
---

| \* Effectful Computations / 2
--

```
def mean(xs: List[Int]): Option[Int] =
  if (xs.empty) None else Some(xs.sum / xs.length)
```

--

```
mean(List(4, 6, 5))
```
--

```
mean(List())
```

---

| \* Effectful computations composition

```
val f: A => F[B] = ???
val g: B => F[C] = ???

def compose(f: A => F[B], g: B => F[C]): A => F[C] = ???
```
---

| \* Effectful computations composition

```
def creditCard(cc: String): Option[CreditCard] = creditCards.find(_.number == cc)

def stuffToBuy(cc: CreditCard): Option[Item] = if (cc.balance < 250)
    None
  else if (250 < cc.balance && cc.balance < 350)
    Some(Item.Shoes)
  else
    Some(Item.PS4)
```
--

```
val itemByCC: String => Option[Item] = compose(creditCard, stuffToBuy)
```
---

| \* Effectful computations composition

```
def composeOpt[A, B, C](f: A => Option[B], g: B => Option[C]): A => Option[C] =
  a => {
    for {
      b <- f(a)
      c <- g(b)
    } yield c
  }
```
--

```
def itemByCC: String => Option[Item] = composeOpt(creditCard, stuffToBuy)
```

---

| \* Effectful computations composition

This works for any Monad

```
def composeOpt[A, B, C, F[_]](f: A => F[B], g: B => F[C])
  (implicit F: Monad[F]): A => F[C] =
  a => {
    for {
      b <- f(a)
      c <- g(b)
    } yield c
  }
```
---

| \* Effectful computations composition
| \* Kleisli

Reasonable patterns already exist (in scalaz)!!!
--

```
case class Kleisli[M[_], A, B](run: A => M[B]) {

  def andThen[C](k: Kleisli[M, B, C])(implicit b: Monad[M]) =
    Kleisli[M, A, C]((a: A) => b.bind(this(a))(k.run))

  def compose[C](k: Kleisli[M, C, A])(implicit b: Monad[M]) =
    k andThen this
}
```

---
| \* Effectful computations composition
| \* Kleisli

```
val creditCardK = Kleisli(creditCard)
val stuffToBuyK = Kleisli(stuffToBuy)
```
--

```

val itemByCCK =  stuffToBuyK compose creditCardK

```

--

```

itemByCCK.run("5413330300001006")

```

---
| \* Effectful computations composition

```
class Monad[F[_]] {
  def pure[A]: F[A]
  def flatMap[A, B](fa: F[A])(f: A => F[B]): F[B]

  def map[A, B](fa: F[A])(f: A => B) = flatMap(fa)(a => pure(f(a))
  def compose[A, B, C](f: A => F[B], g: B => F[C]): A => F[C] = ...
}
```
--

| \* Kleisli equivalent to Monad

```
class Monad[F[_]] {
  def pure[A]: F[A]
  def compose[A, B, C](f: A => F[B], g: B => F[C]): A => F[C] =

  def flatMap[A, B](fa: F[A])(f: A => F[B]): F[B] = ...
  def map[A, B](fa: F[A])(f: A => B) = flatMap(fa)(a => pure(f(a))
}
```

---
| \* Effectful computations composition

< :red_circle: Kleisli equivalent to Monad

< :red_circle: Associativity law is simpler with Kleisli
--

< :red_circle: ReaderT is a Kleisli
--

| \* ...to be continued



